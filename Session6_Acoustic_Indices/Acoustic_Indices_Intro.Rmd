---
title: "Acoustic_Indices"
author: "Carlos Abrahams"
date: "08/06/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load packages}

library(tuneR)
library(seewave)

```


# ACOUSTIC INDICES

## Introduction
The acoustic data recorded using bioacoustic methods can be analysed in great depth to identify species, or even individual animals - but this can be time-consuming, and requires significant identification expertise. However, a  range of indices have been developed for characterising acoustic field recordings in broader terms, summarising audio data to produce numerical scores that are ecologically meaningful, and that can be to assess biodiversity, including species richness, community diversity, and functional traits.  An acoustic index is a statistic that summarizes some aspect of the distribution of acoustic energy and information in a recording (Towsey et al., 2014) - providing an indication of its ecological 'quality' and a link to biodiversity metrics. Acoustic indices are increaingly being used to characterise and investigate ecological recordings, without the need to recognise individual species.  

We will look at one sort of index - the Acoustic Complexity Index (ACI) - which is designed to be related to the diversity of bird song, and hence bird species richness.

## Acoustic Complexity Index

The ACI was developed to quantify complex biotic sounds according to the variability of the intensities recorded, while filtering out background human-generated noise (anthrophony). The algorithm is based on the observation that many biotic sounds, including bird songs (for which it was principally developed), typically have frequent dynamic changes in their volume, while many types of human generated noise have constant amplitude - such as the drones or rumbles of traffic noise (Farina 2008; Pieretti 2011). The ACI provides a measure of how much the sound intensity varies over time, by calculating the differences in amplitude, for a range of frequency bins, between adjacent time periods in a recording. In this way, the ACI extracts the majority of biologically produced sound while reducing the non-biotic sounds and the effects of distance of sound from the microphone. 

When applying the ACI, it is necessary to note that strong intensity modulations can sometimes be generated by humans, or weather conditions. The ACI is resistant to continuous noise, such as aeroplane flights overhead or traffic noise, but sensitive to variable noise sources such as rain and irregular machine activity. These intermittent, irregular man-made sounds can cause a rapid variation of intensities, and a correspondingly high ACI score. Accordingly, the ACI should be used preferably in more semi-natural soundscapes, where any anthropogenic noise present in the soundscape is characterized by constant intensities, rather than in complex, noisy urban environments. In addition, although the ACI algorithm reduces the variability introduced by the singing organisms being different distances from the recording microphones, it is still moderately sensitive to the proximity of the sound source and close sounds will result in a higher ACI value than those at greater distance.


```{r add libraries}
#You will need to make sure that the tidyverse, tuneR, seewave and lubridate packages are installed.
#Run the following code if needed
#install.packages("tidyverse", "tuneR", "seewave", "lubridate")

#Activate tidyverse package for data nhandling
library(tidyverse)
#Activate tuneR readWave import function
library(tuneR)  
#Activate seewave for ACI function
library(seewave)
#Activate seewave for ACI function
library(lubridate)


```

We're going to use the "Carsington 3day 3ARU" dataset that you have been provided with.  This consists of 1 minute wav files, recorded every hour at dawn, for 3 days at 3 automated recorder locations - a plantation, broadleaved woodland, and reedbed.  

Before that though, we'll start by just loading and displaying a single .wav file at a time, using the wav data built into the seewave package.

```{r view and ACI the seewave data files}

#Load the seewave lapwing call data
data(peewit)

#Display a spectrogram for the lapwing call data
spectro(peewit)

#Load the seewave song data for neotropical sparrow
data(tico)

#Display a spectrogram for the sparrow song data
spectro(tico)

#Calculate the ACI for the lapwing call
ACI(peewit)

#Calculate the ACI for the sparrow song
ACI(tico)

```
The ACI scores are 270.7 for the Sparrow song, and 239.9 for the lapwing.  These don't mean that much, but are an indication that the sparrow song has more volume variation than the lapwing call.

Now try this for some of our data.

```{r view and ACI some individual wav files}


#Read in a single .wave file from the dataset
#example_wav <- readWave(
  
#or use the commented out text below  
#example_wav <- readWave(file.choose())

#Display a spectrogram of the wav
#You can use the flim variable to constrain the spectrogram frequency scale
#spectro(example_wav, flim = c(0,12))

#Calculate the ACI score for the wav
#ACI(example_wav)

```

We can do this same analysis for a set of .wav files using the following code.  

Warning - With the provided dataset of 45 files, each being recorded at 48kHz sample rate in stereo, this process takes 3-4 minutes on a relatively fast laptop.

```{r import acoustic data}

#Create a new R object, containing a list of all the .wav files in the dataset 
#You will need to provide your own filepath in the command below, pointing to the dataset location
#Perhaps use Session > Set Working Directory ?

wav_list <- list.files("Carsington_3day_3ARU", recursive = TRUE, full.names = TRUE)

#Now we need to create a blank vector object to write the ACI scores into
#We create a numeric list of [zero] numbers, the same length as the number of wav files
aci_list <- vector("double", length(wav_list))

#Read wavs and calculate ACI scores
#The code below uses a 'for' loop to read the wav, calculate ACI and write the result into aci_list
for (i in seq_along(wav_list)) {
wav <- readWave(str_c(wav_list[i]))
aci_list[[i]] <- ACI(wav)
}

#Combine file names and ACI scores
wav_aci <- as_tibble(cbind(wav_list, aci_list))
#Ensure the aci_list scores are numeric, and not listed as a character string
wav_aci$aci_list <- as.numeric(wav_aci$aci_list)



```

We now have a dataframe with the (very long) filename for each .wav file and the corresponding ACI score.  You can check this using the glimpse function.

```{r glimpse wav_aci file}

#Glimpse wav_aci
glimpse(wav_aci)

```

To allow further analysis, we want to get the recorder reference, date and time for each .wav file. We'll do this using some string functions to manipulate the filename, and functions from the 'lubridate' package to help with dates and times.

```{r generate recorder, date and time columns}


#Create a new recorder column from the filename string
wav_aci$recorder <- str_sub(wav_aci$wav_list, -28, -21)

#Create a date_time columnn
wav_aci$date <- ymd(str_sub(wav_aci$wav_list, -19, -12))

#Create a time column
wav_aci$time <- str_sub(wav_aci$wav_list, -10, -5)

#Create an hour column
wav_aci$hour <- str_sub(wav_aci$time, 1, 2)


```

Check your wav_aci dataframe again after these changes.  Maybe use summary this time?

```{r summary wav_aci file}

#Get summary of wav_aci
summary(wav_aci)

```

And let's plot a histogram of the ACI scores to check the data distribution.


```{r histogram of ACI}

#Plot a histogram of the ACI scores
ggplot(data = wav_aci) +
  geom_histogram(aes(x= aci_list), bins = 20)

```

To compare the ACI values at each recorder location, we can produce a boxplot to show the median and interquartiles for each location. Unit 8621 is the reedbed, 8552 the broadleaved woodland and 8535 the plantation.

```{r display ACI boxplot per recorder}

#Plot a boxplot, showuing ACI for each recorder location
ggplot() +
  geom_boxplot(data = wav_aci, aes(x = recorder, y = aci_list)) +  
  theme_classic() +
  xlab("Recorder") +
  ylab("ACI") 

```

Let's see how the ACI varies over time, using another boxplot to start with.

```{r display ACI against time}

#Plot a boxplot, showing the ACI scores for each hour recorded
ggplot(wav_aci, aes(x= hour, y = aci_list)) +
  geom_boxplot() +
  labs(title = "ACI scores per hour, summarised across all days and recorders")

```

Following that, let's plot a line graph to show the mean ACI at each site over the 3-day period, and then a smoothed line, with 95% CI, for all the data over the 3-day survey.

```{r display ACI against date}

#Produce summary of the ACI data, with the mean ACI for each day at each site
daymeanACI <- wav_aci %>%
  group_by(recorder, date) %>%
  summarise(mean(aci_list))

#Plot a line graph, with recorder location facet, various theme (appearance) changes and titles.
ggplot() +
  geom_line(data = daymeanACI, aes(x = date, y = `mean(aci_list)` )) +
  facet_wrap(~recorder) +
  theme_bw() +
  theme(strip.background = element_rect(colour="white", fill="white")) +
  theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) +
  xlab("date") +
  ylab("ACI") +
  labs(title ="ACI variation at each sampling location over 3 day recording period")

```

```{r display ACI against date 2, message=FALSE, error= FALSE}

#Plot a smooth fitted line with 95% CI to the ACI data
ggplot(data = wav_aci, aes(x = date, y = aci_list)) +
  geom_smooth(method = "loess") +
  theme_classic() +
  theme(strip.background = element_rect(colour="white", fill="white")) +
  xlab("Date") +
  ylab("ACI") +
  labs(title ="ACI variation over 3 day recording period")


```

